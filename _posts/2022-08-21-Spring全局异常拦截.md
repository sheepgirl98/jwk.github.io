---
layout: post title:  "全局异常拦截"
date:   2022-08-21
---

# Spring boot全局异常统一拦截

**前言:**

spring boot学习以及使用也有一段时间了,平时疏于整理资料,故今日写一篇关于全局异常的资料

**背景:**

异常处理是为了给用户带来良好的交互体验

**异常:**

- 访问了错误的页面,或者是非法的访问导致服务器不能返回正常的数据,例如访问了不存在的页面导致404
- 程序代码内部的错误,在开发时期由于没有考虑周全导致的程序异常,列如常见的空指针异常(NullPointException)

**操作:**

关于第一种处理:

可以定义一个ErrorController来进行全局的处理,如果404则会跳转到404.html页面,这种处理会根据statusCode返回相对应的页面,当然这里也可以设置返回成json的数据格式,只要在方法上加上@ResponseBody,然后修改返回值即可.

```java
import org.springframework.boot.web.servlet.error.ErrorController;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;

@Controller
public class MainSiteErrorController implements ErrorController {

    @RequestMapping("/error")
    public String handleError(HttpServletRequest request) {
        System.out.println("成功拦截异常信息");
        //获取statusCode:401,404,500
        Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (statusCode == 401) {
            return "/error.html";
        } else if (statusCode == 404) {
            return "/404.html";
        } else if (statusCode == 403) {
            return "/error.html";
        } else if (statusCode == 500) {
            return "/error.html";
        } else {
            return "/error.html";
        }
    }

    @Override
    public String getErrorPath() {
        return "/error";
    }

}
```

关于第二种处理:

可以定义一个GlobalExceptionHandler全局异常处理类,在类上加@ControllerAdvice异常拦截注解,在方法上面加入@ExceptionHandler(对应的异常类.class)
注解,这种方法可以是多个的,Exception是全局的异常处理,如果有ArithmeticException的异常则会优先跳入对应的ArithmeticException处理方法中,则不会进入Exception处理方法中,

```java
import com.example.demo.response.BusinessException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@ControllerAdvice
public class GlobalExceptionHandler {

    // 这里由于类上使用的注解为 @ControllerAdvice 且方法上未使用 @ResponseBody 所有这里返回的是错误页面的路径
    @ExceptionHandler(ArithmeticException.class)
    private String ArithmeticException(HttpServletRequest request, Exception e) {
        System.out.println("ArithmeticException成功拦截");
        return "/error.html";
    }

    // 这里由于类上使用的注解为 @ControllerAdvice 且方法上使用 @ResponseBody 所有这里返回的json格式的数据
    // 捕获自定义的异常
    @ExceptionHandler(BusinessException.class)
    @ResponseBody
    private Object handlerBusinessException(HttpServletRequest request, HttpServletResponse response, BusinessException e) {
        System.out.println("GlobalException成功拦截");

        // 设置http-status
        response.setStatus(e.getResponseCode().getHttpStatus());

        return "捕获自定义的异常";
    }

    // 这里由于类上使用的注解为 @ControllerAdvice 且方法上使用 @ResponseBody 所有这里返回的json格式的数据
    @ExceptionHandler(Exception.class)
    @ResponseBody
    private Object handlerErrorInfo(HttpServletRequest request, HttpServletResponse response, Exception e) {
        System.out.println("GlobalException成功拦截");

        // 设置http-status
        response.setStatus(505);

        return "服务器异常,请联系管理员处理";
    }
}
```

自定义异常

```java
public class BusinessException extends RuntimeException {

    private final ResponseCode responseCode;

    public BusinessException(ResponseCode responseCode, String message) {
        super(message);
        this.responseCode = responseCode;
    }

    public ResponseCode getResponseCode() {
        return responseCode;
    }
}
```

错误枚举

```java
public enum ResponseCode {


    SYSTEM_ERROR("SY.00001", "总定义的错误", 500);

    private final String errorCode;

    private final String errorMsg;

    private final int httpStatus;


    ResponseCode(String errorCode, String errorMsg, int httpStatus) {
        this.errorCode = errorCode;
        this.errorMsg = errorMsg;
        this.httpStatus = httpStatus;
    }

    public String getErrorCode() {
        return errorCode;
    }

    public String getErrorMsg() {
        return errorMsg;
    }

    public int getHttpStatus() {
        return httpStatus;
    }
}
```

总结:
运行时异常返回的状态码是500,但是会优先被GlobalExceptionHandler拦截,而对应的异常像上文中ArithmeticException(例如int i = 1/0)
除数不能为0的异常,会优先被ArithmeticException()这个方法所捕获.

总的来说上面两种异常处理的执行顺序是 ArithmeticException>Exception>errorController

[原文链接](https://blog.csdn.net/qq_34698318/article/details/90604044)

### @RestControllerAdvice与@ControllerAdvice的区别

> @RestControllerAdvice与@ControllerAdvice的区别就和@RestController与@Controller的区别类似，@RestControllerAdvice注解包含了@ControllerAdvice注解和@ResponseBody注解。

@RestControllerAdvice源码中有@ControllerAdvice注解和@ResponseBody注解，当自定义类加@RestControllerAdvice注解时，方法自动返回json数据，每个方法无需再添加@ResponseBody注解

```java

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ControllerAdvice
@ResponseBody
public @interface RestControllerAdvice {
    @AliasFor("basePackages")
    String[] value() default {};

    @AliasFor("value")
    String[] basePackages() default {};

    Class<?>[] basePackageClasses() default {};

    Class<?>[] assignableTypes() default {};

    Class<? extends Annotation>[] annotations() default {};
}
```

@ControllerAdvice 当自定义类加@ControllerAdvice注解时，方法需要返回json数据时，每个方法还需要添加@ResponseBody注解

```java

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface ControllerAdvice {
    @AliasFor("basePackages")
    String[] value() default {};

    @AliasFor("value")
    String[] basePackages() default {};

    Class<?>[] basePackageClasses() default {};

    Class<?>[] assignableTypes() default {};

    Class<? extends Annotation>[] annotations() default {};

}
```

复习一下Spring注解@Controller和@RestController的区别？

1)如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return
里的内容。

例如：本来应该到success.jsp页面的，则其显示success.

2)如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。 3)
如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。

1.使用`@Controller` 注解

在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面,若返回json等内容到页面，则需要加@ResponseBody注解

2.使用`@RestController` 注解

相当于@Controller+@ResponseBody两个注解的结合，返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面

[原文链接](https://blog.csdn.net/xing930408/article/details/108623138)
