# 证书验证

> 规则：在SSL/TLS、IPSEC等使用数字证书实现身份认证的场景，必须验证对端证书的有效性，必选验证项包括对端证书是否由受信根CA签发、是否在有效期内。

证书校验 主要分为双向认证（客户端校验服务端证书，服务端校验客户端证书）和单向认证（客户端校验服务端证书）

### 不校验证书

第一种

自己实现TrustManager，里面checkClientTrusted和checkServerTrusted方法为空即可。
一般情况下，用参数控制，如果配置的为信任所有证书，则可以使用下面的代码

```java
            TrustManager[] trustManagers =
                    new TrustManager[]{
                            new X509TrustManager() {
                                @Override
                                public void checkClientTrusted(X509Certificate[] x509Certificates, String s)
                                        throws CertificateException {
                                    // 方法不做任何实现 
                                }

                                @Override
                                public void checkServerTrusted(X509Certificate[] x509Certificates, String s)
                                        throws CertificateException {
                                    // 方法不做任何实现
                                }

                                @Override
                                public X509Certificate[] getAcceptedIssuers() {
                                    return new X509Certificate[0];
                                }
                            }
                    };
            SSLContext sslContext = SSLContext.getInstance("SSL", "SunJSSE");
            sslContext.init(null, tm, new java.security.SecureRandom());
```

第二种

自定义 SSL 上下文中配置的信任管理器即可建立证书可信度的策略。此接口可用于覆盖标准 JSSE 证书验证过程。

```java

public class CustomSSLContextBuilder {
    public CustomSSLContextBuilder() {
    }

    public SSLContext build() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {
        TrustStrategy acceptingTrustStrategy = (chain, authType) -> {
          // 如果此方法返回 false，则在实际 SSL 上下文中配置的信任管理器仍然可以将证书清除为受信任
          // 方法不做任何校验，直接返回true
            return true;
        };
        SSLContext sslContext = SSLContexts.custom().loadTrustMaterial((KeyStore)null, acceptingTrustStrategy).build();
        return sslContext;
    }
}

// 调用点
SSLContext sslContext = new CBCSSLContextBuilder().build();

```

### 单向认证

> 单向认证满足99%场景，单向认证的场景就是校验服务端证书，那么客户端就必须要导入服务端证书到客户端的信任证书链中，单向认证需要的文件：truststore.jks，这个文件需要包含所有需要通信的服务端的证书。

```java
private static SSLContext buildSSLContext(String certPath, String certPassword)
            throws IOException, NoSuchAlgorithmException, KeyStoreException, CertificateException,
                    KeyManagementException {
        SSLContext sslContext = SSLContext.getInstance("TLSv1.2");

        try (InputStream inputStream = UsFileUtils.getFileInputStream(certPath)) {
            KeyStore keyStore = KeyStore.getInstance("JKS");
            keyStore.load(inputStream, certPassword.toCharArray());
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(keyStore);

            sslContext.init(null, tmf.getTrustManagers(), null);
        }

        return sslContext;
    }
```

### 双向认证

双向认证要验证服务端的证书和客户端证书，需要设置KeyManager和TrustManger，所以需要两个文件：keystore和truststore，当前都默认用JKS。
KeyManager 和 TrustManager在Java中执行不同的工作，TrustManager 确定是否应该信任远程连接，即远程方是否是它声称的人，并且KeyManager决定在SSL握手期间应该将哪些认证凭证发送给远程主机以进行认证。如果您是SSL服务器，您将在密钥交换算法期间使用私钥并将与您的公钥对应的证书发送到客户端，此证书是从keystore获取的。也就是服务端证书。如果是Java编写，它将使用存储在truststore中的证书来验证远端的身份。所以将根证书导入 truststore中即是此目的。
代码示例：

```java
private static SSLContext buildDualSSLContext(
            String keyStorePath, String keyStorePassword, String certPath, String certPassword)
            throws IOException, NoSuchAlgorithmException, KeyStoreException, CertificateException,
                    KeyManagementException, UnrecoverableKeyException {
        SSLContext sslContext = SSLContext.getInstance("TLSv1.2");
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

        try (InputStream ksInput = UsFileUtils.getFileInputStream(keyStorePath);
                InputStream tksInput = UsFileUtils.getFileInputStream(certPath)) {
            // 本地keystore
            KeyStore ks = KeyStore.getInstance("JKS");
            ks.load(ksInput, keyStorePassword.toCharArray());
            kmf.init(ks, keyStorePassword.toCharArray());

            // 信任truststore
            KeyStore tks = KeyStore.getInstance("JKS");
            tks.load(tksInput, certPassword.toCharArray());
            tmf.init(tks);

            sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
        }
        return sslContext;
    }
```

### 服务端证书获取和导入

#### 服务端证书获取

一般有两种获取方式：1.由服务端提供；2.如果可以直接访问服务端的地址的话，可以使用如下方法获取https://blog.csdn.net/c5113620/article/details/80384660

#### 证书导入

truststore.jks为客户端信任证书链，如果通过https访问第三方时报错，报如下错误:

```
javax.net.ssl.SSLHandshakeException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
```

则需要将服务端证书（上面获取的）导入到truststore.jks中，命令如下：

```
keytool -import -alias clientCert -file client.crt -keystore truststore.jks -storepass WeiHjksAdmin@HW123
-alias后面的参数是别名，取个唯一的即可
-file后面的参数是服务端证书
-keystore后面的参数就是客户端信任证书
-storepass为证书密码
```

执行完命令后，记得重启容器。
查看证书链命令：
```
keytool -list -v -keystore truststore.jks -storepass WeiHjksAdmin@HW123
```

### 证书锁定

> 证书锁定是用来限制哪些证书和证书颁发机构是可信任的。需要我们直接在代码中固定写死使用某个服务器的证书，然后用自定义的信任存储去代替系统系统自带的，再去连接我们的服务器。一般是指JVM的keyStore。

1、在服务端生成.keystore

```
shell keytool -genkey -alias xxx -keyalg RSA -keysize 1024 -keypass keypass -validity 365 -keystore xxx.keystore -storepass keypasswd
```

2、在客户端根据服务端keystore导入到cacerts

```
shell keytool -import -alias xxx -keystore cacerts -file xxx.keystore
```

3、客户端连接服务端

优缺点对比
优点	缺点
自定义X509TrustManager	灵活性高，纯代码实现	安全性低，校验逻辑写的不好容易出现中间人攻击
cacerts	安全性高	灵活性差，服务端证书变更后通常需要重新构造cacerts
